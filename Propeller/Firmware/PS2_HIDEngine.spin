{{///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// PS2 Human Interface Device Engine//// Author: Kwabena W. Agyeman// Updated: 7/27/2010// Designed For: P8X32A// Version: 1.1//// Copyright (c) 2010 Kwabena W. Agyeman// See end of file for terms of use.//// Update History://// v1.0 - Original release - 5/30/2008.// v1.1 - Updated code and fixed communication issues - 7/27/2010.//// For each included copy of this object only one spin interpreter should access it at a time.//// Nyamekye,//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// PS2 Circuit:////                     3.3V//                      |//                      R 10KOHM//                      |// Keyboard Clock Pin ----- Keyboard Clock////                     3.3V//                      |//                      R 10KOHM//                      |// Keyboard Data Pin  ----- Keyboard Data////                      5V//                      |//                      --- Keyobard Power//                      --- Keyboard Ground//                      |//                     GND////                     3.3V//                      |//                      R 10KOHM//                      |// Mouse Clock Pin    ----- Mouse Clock////                     3.3V//                      |//                      R 10KOHM//                      |// Mouse Data Pin     ----- Mouse Data////                      5V//                      |//                      --- Mouse Power//                      --- Mouse Ground//                      |//                     GND///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////}}CON  #0, A_Key, B_Key, C_Key, D_Key, E_Key, F_Key, G_Key, H_Key, I_Key, J_Key, K_Key, L_Key, M_Key, {    } N_Key, O_Key, P_Key, Q_Key, R_Key, S_Key, T_Key, U_Key, V_Key, W_Key, X_Key, Y_Key, Z_Key, {    } Zero_Key, One_Key, Two_Key, Three_Key, Four_Key, Five_Key, Six_Key, Seven_Key, Eight_Key, Nine_Key, {    } Apostrophe_Key, Comma_Key, Hyphen_Key, Period_Key, Forward_Slash_Key, {    } Semicolon_Key, Equals_Sign_Key, Left_Bracket_Key, Back_Slash_Key, Right_Bracket_Key, {    } Grave_Accent_Key, {    } Backspace_key, Tab_Key, Space_Key, Enter_Key, {    } Enter_Key_Pad_Key, Asterisk_Key_Pad_Key, Plus_Sign_Key_Pad_Key, {    } Hyphen_Key_Pad_Key, Fowrad_Slash_Key_Pad_Key, Period_Key_Pad_Key, {    } Zero_Key_Pad_Key, One_Key_Pad_Key, Two_Key_Pad_Key, Three_Key_Pad_Key, Four_Key_Pad_Key, {    } Five_Key_Pad_Key, Six_Key_Pad_Key, Seven_Key_Pad_Key, Eight_Key_Pad_Key, Nine_Key_Pad_Key, {    } Scroll_Lock_Key, Number_Lock_Key, Caps_Lock_Key, {    } Left_Shift_Key, Left_Control_Key, Left_Alternative_Key, Left_Windows_Key, {    } Right_Shift_Key, Right_Control_Key, Right_Alternative_Key, Right_Windows_Key, {    } Left_Arrow_Key, Right_Arrow_Key, Up_Arrow_Key, Down_Arrow_Key, {    } Page_Up_Key, Page_Down_Key, Home_Key, End_Key, Insert_Key, Delete_Key, {    } Escape_Key, Applications_Key, Print_Screen_Key, Pause_Break_Key, {    } F1_Key, F2_Key, F3_Key, F4_Key, F5_Key, F6_Key, F7_Key, F8_Key, F9_Key, F10_Key, F11_Key, F12_Key  #129, Scroll_Lock_Event, Number_Lock_Event, Caps_Lock_Event, {      } Left_Shift_Event, Left_Control_Event, Left_Alternative_Event, Left_Windows_Event, {      } Right_Shift_Event, Right_Control_Event, Right_Alternative_Event, Right_Windows_Event, {      } Left_Arrow_Event, Right_Arrow_Event, Up_Arrow_Event, Down_Arrow_Event, {      } Page_Up_Event, Page_Down_Event, Home_Event, End_Event, Insert_Event, Delete_Event, {      } Escape_Event, Applications_Event, Print_Screen_Event, Pause_Break_Event, {      } F1_Event, F2_Event, F3_Event, F4_Event, F5_Event, F6_Event, {      } F7_Event, F8_Event, F9_Event, F10_Event, F11_Event, F12_Event  #8, Bacspace_Event, Tab_Event, Line_Feed_Event, #13, Carriage_Return_EventPUB keyboardButton(buttonNumber) '' 4 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Returns the selected keyboard button state.'' //'' // ButtonNumber - The keyboard button to return the current state of.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  buttonNumber := ((buttonNumber <# 103) #> 0)  result or= (keyboardButtonStates[buttonNumber >> 3] & (|<(buttonNumber & $7)))PUB keyboardScrollLock '' 3 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Returns the current scroll lock state - true or false. This is not the state of the key but the LED and modifier.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  result or= (keyboardLockStates & $1)PUB keyboardNumberLock '' 3 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Returns the current number lock state - true or false. This is not the state of the key but the LED and modifier.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  result or= (keyboardLockStates & $2)PUB keyboardCapsLock '' 3 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Returns the current caps lock state - true or false. This is not the state of the key but the LED and modifier.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  result or= (keyboardLockStates & $4)PUB XPosition '' 3 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Returns the current mouse x axis position.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  return mouseXAxisPositionPUB YPosition '' 3 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Returns the current mouse y axis position.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  return mouseYAxisPositionPUB ZPosition '' 3 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Returns the current mouse z axis position.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  return mouseZAxisPositionPUB XPositionAddress '' 3 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Returns the address of the mouse x axis position variable.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  return @mouseXAxisPositionPUB YPositionAddress '' 3 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Returns the address of the mouse y axis position variable.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  return @mouseYAxisPositionPUB leftButton '' 3 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Returns the current left mouse button state.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  result or= (mouseButtonStates & $1)PUB rightButton '' 3 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Returns the current right mouse button state.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  result or= (mouseButtonStates & $2)PUB middleButton '' 3 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Returns the current middle mouse button state.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  result or= (mouseButtonStates & $4)PUB keyboardEvent '' 6 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Returns the next event in the keyboard event buffer.'' //'' // Waits until there is an event to return if the keyboard event buffer is empty.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  setKeyboardLock  repeat until(keyboardEventNumber)  result := keyboardEvents[keyboardEventsTail++]  clearKeyboardLockPUB keyboardEventNumber '' 3 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Returns the number of events in the keyboard event buffer.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  return ((keyboardEventsHead - keyboardEventsTail) & $FF)PUB keyboardEventsFull '' 6 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Returns true if the keyboard event buffer is full and false if it is not.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  return (keyboardEventNumber == 255)PUB keyboardEventsFlush '' 6 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Empties the keyboard event buffer.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  setKeyboardLock  keyboardEventsTail := keyboardEventsHead  clearKeyboardLockPUB mouseEvent '' 6 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Returns the next event in the mouse event buffer.'' //'' // Waits until there is an event to return if the mouse event buffer is empty.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  setMouseLock  repeat until(mouseEventNumber)  result := mouseEvents[mouseEventsTail++]  clearMouseLockPUB mouseEventNumber '' 3 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Returns the number of events in the mouse event buffer.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  return ((mouseEventsHead - mouseEventsTail) & $FF)PUB mouseEventsFull '' 6 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Returns true if the mouse event buffer is full and false if it is not.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  return (mouseEventNumber == 255)PUB mouseEventsFlush '' 6 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Empties the mouse event buffer.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  setMouseLock  mouseEventsTail := mouseEventsHead  clearMouseLockPUB keyboardEventPrintable(keyboardEventWord) '' 4 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Extracts from a keyboard event if the keyboard event is a printable character. Returns true or false.'' //'' // Special Characters:'' //'' // 129 - Scroll Lock, 130 - Number Lock, 131 - Caps Lock'' // 132 - Left Shift, 133 - Left Control, 134 - Left Alternative, 135 - Left Windows'' // 136 - Right Shift, 137 - Right Control, 138 - Right Alternative, 139 - Right Windows'' // 140 - Left Arrow, 141 - Right Arrow, 142 - Up Arrow, 143 - Down Arrow'' // 144 - Page Up, 145 - Page Down, 146 - Home, 147 - End, 148 - Insert, 149 - Delete'' // 150 - Escape, 151 - Applications, 152 - Print Screen System Request, 153 - Pause Break'' // 154 - F1, 155 - F2, 156 - F3, 157 - F4, 158 - F5, 159 - F6,'' // 160 - F7, 161 - F8, 162 - F9, 163 - F10, 164 - F11, 165 - F12'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  return ((keyboardEventWord & $FF) < 127)PUB keyboardEventCharacter(keyboardEventWord) '' 4 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Extracts from a keyboard event the keyboard event character.'' //'' // Special Characters:'' //'' // 129 - Scroll Lock, 130 - Number Lock, 131 - Caps Lock'' // 132 - Left Shift, 133 - Left Control, 134 - Left Alternative, 135 - Left Windows'' // 136 - Right Shift, 137 - Right Control, 138 - Right Alternative, 139 - Right Windows'' // 140 - Left Arrow, 141 - Right Arrow, 142 - Up Arrow, 143 - Down Arrow'' // 144 - Page Up, 145 - Page Down, 146 - Home, 147 - End, 148 - Insert, 149 - Delete'' // 150 - Escape, 151 - Applications, 152 - Print Screen System Request, 153 - Pause Break'' // 154 - F1, 155 - F2, 156 - F3, 157 - F4, 158 - F5, 159 - F6,'' // 160 - F7, 161 - F8, 162 - F9, 163 - F10, 164 - F11, 165 - F12'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  return (keyboardEventWord & $FF)PUB keyboardEventScrollLockState(keyboardEventWord) '' 4 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Extracts from a keyboard event if the scroll lock was on during that event. Returns true or false.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  result or= (keyboardEventWord & $1_00)PUB keyboardEventNumberLockState(keyboardEventWord) '' 4 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Extracts from a keyboard event if the number lock was on during that event. Returns true or false.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  result or= (keyboardEventWord & $2_00)PUB keyboardEventCapsLockState(keyboardEventWord) '' 4 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Extracts from a keyboard event if the caps lock was on during that event. Returns true or false.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  result or= (keyboardEventWord & $4_00)PUB keyboardEventMakeOrBreak(keyboardEventWord) '' 4 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Extracts from a keyboard event if the event key was pressed or released. True for pressed and false for released.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  result or= (keyboardEventWord & $8_00)PUB keyboardEventShiftState(keyboardEventWord) '' 4 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Extracts from a keyboard event if any shift key was held down during that event. Returns true or false.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  result or= (keyboardEventWord & $10_00)PUB keyboardEventControlState(keyboardEventWord) '' 4 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Extracts from a keyboard event if any control key was held down during that event. Returns true or false.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  result or= (keyboardEventWord & $20_00)PUB keyboardEventAlternativeState(keyboardEventWord) '' 4 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Extracts from a keyboard event if any alternative key was held down during that event. Returns true or false.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  result or= (keyboardEventWord & $40_00)PUB keyboardEventWindowsState(keyboardEventWord) '' 4 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Extracts from a keyboard event if any windows key was held down during that event. Returns true or false.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  result or= (keyboardEventWord & $80_00)PUB mouseEventLeftPressed(mouseEventLong) '' 4 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Extracts from a mouse event if the left button was pressed during that event. Returns true or false.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  result or= (mouseEventLong & $1)PUB mouseEventRightPressed(mouseEventLong) '' 4 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Extracts from a mouse event if the right button was pressed during that event. Returns true or false.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  result or= (mouseEventLong & $2)PUB mouseEventMiddlePressed(mouseEventLong) '' 4 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Extracts from a mouse event if the middle button was pressed during that event. Returns true or false.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  result or= (mouseEventLong & $4)PUB mouseEventLeftReleased(mouseEventLong) '' 4 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Extracts from a mouse event if the left button was released during that event. Returns true or false.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  result or= (mouseEventLong & $8)PUB mouseEventRightReleased(mouseEventLong) '' 4 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Extracts from a mouse event if the right button was released during that event. Returns true or false.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  result or= (mouseEventLong & $10)PUB mouseEventMiddleReleased(mouseEventLong) '' 4 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Extracts from a mouse event if the middle button was released during that event. Returns true or false.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  result or= (mouseEventLong & $20)PUB mouseEventXMovement(mouseEventLong) '' 4 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Extracts from a mouse event if there was X position movement during that event. Returns true or false.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  result or= (mouseEventLong & $40)PUB mouseEventYMovement(mouseEventLong) '' 4 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Extracts from a mouse event if there was Y position movement during that event. Returns true or false.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  result or= (mouseEventLong & $80)PUB mouseEventXPosition(mouseEventLong) '' 4 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Extracts from a mouse event the X position recorded during that event.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  return ((mouseEventLong >> 8) & $F_FF)PUB mouseEventYPosition(mouseEventLong) '' 4 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Extracts from a mouse event the Y position recorded during that event.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  return (mouseEventLong >> 20)PUB mouseEventXPixelBounds(startPixel, endPixel, mouseEventLong) '' 10 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Returns true if the mouse event is on or between the two provided pixel columns and false if not.'' //'' // StartPixel - The pixel column to check to see if the mouse is on or after.'' // EndPixel - The pixel column to check to see if the mouse is on or before.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  result := mouseEventXPosition(mouseEventLong)  return ((startPixel =< result) and (result =< endPixel))PUB mouseEventYPixelBounds(startPixel, endPixel, mouseEventLong) '' 10 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Returns true if the mouse event is on or between the two provided pixel rows and false if not.'' //'' // StartPixel - The pixel row to check to see if the mouse is on or after.'' // EndPixel - The pixel row to check to see if the mouse is on or before.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  result := mouseEventYPosition(mouseEventLong)  return ((startPixel =< result) and (result =< endPixel))PUB mouseEventTileRow(mouseEventLong) '' 8 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Extracts from a mouse event the tile row position recorded during that event.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  return (mouseEventYPosition(mouseEventLong) >> 4)PUB mouseEventTileColumn(mouseEventLong) '' 8 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Extracts from a mouse event the tile column position recorded during that event.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  return (mouseEventXPosition(mouseEventLong) >> 4)PUB mouseEventRowBounds(startRow, endRow, mouseEventLong) '' 14 Stack Longs,'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Returns true if the mouse event is on or between the two provided rows and false if not.'' //'' // StartRow - The row to check to see if the mouse is on or after.'' // EndRow - The row to check to see if the mouse is on or before.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  result := mouseEventTileRow(mouseEventLong)  return ((startRow =< result) and (result =< endRow))PUB mouseEventColumnBounds(startColumn, endColumn, mouseEventLong) '' 14 Stack Longs,'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Returns true if the mouse event is on or between the two provided columns and false if not.'' //'' // StartColumn - The column to check to see if the mouse is on or after.'' // EndColumn - The column to check to see if the mouse is on or before.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  result := mouseEventTileColumn(mouseEventLong)  return ((startColumn =< result) and (result =< endColumn))PUB keyboardReady '' 3 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Returns true if the keyboard is present and ready and false if not.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  result or= keyboardPresentPUB mouseReady '' 3 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Returns true if the mouse is present and ready and false if not.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  result or= mousePresentPUB keyboardConfiguration(newKeyboardTypematicDelay, newKeyboardTypematicRate) '' 5 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Changes the current keyboard configuration.'' //'' // NewKeyboardTypematicDelay - (0 = 0.25 seconds) , (1 = 0.50 seconds) , (2 = 0.75 seconds) , (3 - 1.00 seconds).'' // NewKeyboardTypematicRate - Lower for faster, higher for slower. Between 0 - 31. Table Below.'' //'' // 0 - 30.0 CPS, 08 - 15.0 CPS, 16 - 7.5 CPS, 24 - 3.7 Characters Per Second (CPS).'' // 1 - 26.7 CPS, 09 - 13.3 CPS, 17 - 6.7 CPS, 25 - 3.3 Characters Per Second (CPS).'' // 2 - 24.0 CPS, 10 - 12.0 CPS, 18 - 6.0 CPS, 26 - 3.0 Characters Per Second (CPS).'' // 3 - 21.8 CPS, 11 - 10.9 CPS, 19 - 5.5 CPS, 27 - 2.7 Characters Per Second (CPS).'' // 4 - 20.7 CPS, 12 - 10.0 CPS, 20 - 5.0 CPS, 28 - 2.5 Characters Per Second (CPS).'' // 5 - 18.5 CPS, 13 - 09.2 CPS, 21 - 4.6 CPS, 29 - 2.3 Characters Per Second (CPS).'' // 6 - 17.1 CPS, 14 - 08.6 CPS, 22 - 4.3 CPS, 30 - 2.1 Characters Per Second (CPS).'' // 7 - 16.0 CPS, 15 - 08.0 CPS, 23 - 4.0 CPS, 31 - 2.0 Characters Per Second (CPS).'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  keyboardSettings := ((((newKeyboardTypematicDelay <# 3) #> 0) << 5) | ((newKeyboardTypematicRate <# 31) #> 0))PUB mouseConfiguration(newMouseResoltuion, newMouseScaling) '' 5 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Changes the current mouse configuration.'' //'' // NewMouseResolution - (0 = 1 count/mm), (1 = 2 count/mm), (2 = 4 count/mm), (3 = 8 count/mm).'' // NewMouseScaling - True to turn mouse scaling on and false to turn mouse scaling off.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  mouseSettings := ((((newMouseResoltuion <# 3) #> 0) << 1) | ((not(not(newMouseScaling))) & 1))PUB HIDEngineStart(KClockPin, KDataPin, MClockPin, MDataPin, keyboardLS, mouseXMax, mouseYMax) '' 13 Stack longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Starts up the HID driver running on a cog and checks out a couple of locks for the driver.'' //'' // Returns true on success and false on failure.'' //'' // KClockPin - Pin to use to interface with the keyboard clock line. -1 to disable the keyboard.'' // KDataPin - Pin to use to interface with the keyboard data line. -1 to disable the keyboard.'' // MClockPin - Pin to use to interface with the mouse clock line. -1 to disable the mouse.'' // MDataPin - Pin to use to interface with the mouse data line. -1 to disable the mouse.'' // KeyboardLS - Keyboard initial lock states. Bit 0 - Scroll Lock, Bit 1 - Number Lock, Bit 2 - Cap Lock.'' // MouseXMax - Maximum positive position the mouse can move to. The minimum is zero. The mouse will start at the mid point.'' // MouseYMax - Maximum positive position the mouse can move to. The minimum is zero. The mouse will start at the mid point.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  HIDEngineStop  operationFrequency := (clkfreq / 80_000)  scrollNumCapsLock := (keyboardLS & $7)  cutOffX := ((mouseXMax <# $F_FF) #> 0)  cutOffY := ((mouseYMax <# $F_FF) #> 0)  mouseXAxisPosition := (cutOffX >> 1)  mouseYAxisPosition := (cutOffY >> 1)  mouseXMax := ((KClockPin <# 31) #> 0)  mouseYMax := ((KDataPin <# 31) #> 0)  keyboardLS := ((KClockPin <> -1) and (KDataPin <> -1))  keyboardClock := ((|<mouseXMax) & keyboardLS)  keyboardData := ((|<mouseYMax) & keyboardLS)  mouseXMax := ((MClockPin <# 31) #> 0)  mouseYMax := ((MDataPin <# 31) #> 0)  keyboardLS := ((MClockPin <> -1) and (MDataPin <> -1))  mouseClock := ((|<mouseXMax) & keyboardLS)  mouseData := ((|<mouseYMax) & keyboardLS)  ASCIICodeLookupTableAdd := @ASCIICodeLookupTable  scanCodeLookupTableAdd := @scanCodeLookupTable  mouseXAxisPositionAdd := @mouseXAxisPosition  mouseYAxisPositionAdd := @mouseYAxisPosition  keyboardPresentAdd := @keyboardPresent  mousePresentAdd := @mousePresent  keyboardSettingsAddress := @keyboardSettings  mouseSettingsAddress := @mouseSettings  keyboardEventsHeadAdd := @keyboardEventsHead  keyboardEventsTailAdd := @keyboardEventsTail  mouseEventsHeadAdd :=  @mouseEventsHead  mouseEventsTailAdd := @mouseEventsTail  keyboardEventsAdd := @keyboardEvents  mouseEventsAdd := @mouseEvents  keyboardButtonStatesAdd := @keyboardButtonStates  keyboardLockStatesAdd := @keyboardLockStates  mouseButtonStatesAdd := @mouseButtonStates  keyboardLockNumber := locknew  mouseLockNumber := locknew  cogNumber := cognew(@initialization, @mouseZAxisPosition)  if((++keyboardLockNumber) and (++mouseLockNumber) and (++cogNumber) and (chipver == 1))    return true  HIDEngineStopPUB HIDEngineStop '' 3 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Shuts down the HID driver running on a cog and returns the locks used by the driver.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  if(cogNumber)    cogstop(-1 + cogNumber~)  if(mouseLockNumber)    lockret(-1 + mouseLockNumber~)  if(keyboardLockNumber)    lockret(-1 + keyboardLockNumber~)PRI setKeyboardLock ' 3 Stack Longs  repeat while(lockset(keyboardLockNumber - 1))PRI clearKeyboardLock ' 3 Stack Longs  lockclr(keyboardLockNumber - 1)PRI setMouseLock ' 3 Stack Longs  repeat while(lockset(mouseLockNumber - 1))PRI clearMouseLock ' 3 Stack Longs  lockclr(mouseLockNumber - 1)DAT' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'                       HID Driver' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////                        org     0' //////////////////////Initialization/////////////////////////////////////////////////////////////////////////////////////////initialization          mov     keyboardPC,              #resetKeyboard          ' Initialize PCs.                        mov     mousePC,                 #resetMouse             '                        rdbyte  keyboardEHead,           keyboardEventsHeadAdd   ' Initialize head pointers.                        rdbyte  mouseEHead,              mouseEventsHeadAdd      '                        mov     synchronizeTime,         operationFrequency      ' Setup the sample wait.                        add     synchronizeTime,         cnt                     '' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'                       Synchronization' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////synchronize             waitcnt synchronizeTime,         operationFrequency      ' Synchronize.                        jmpret  synchronizePC,           keyboardPC              '                        jmpret  synchronizePC,           mousePC                 '                        jmp     #synchronize                                     '' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'                       Reset Keyboard' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////resetKeyboard           andn    dira,                    keyboardData            ' Reset keyboard data line state.                        wrbyte  signExtensionMask,       keyboardPresentAdd      '                        mov     keyboardLEDs,            #0                      ' Reset keyboard button states.                        mov     keyboardCounter,         #13                     '                        mov     keyboardBuffer,          keyboardButtonStatesAdd 'resetDraobyek           wrbyte  keyboardLEDs,            keyboardBuffer          '                        add     keyboardBuffer,          #1                      '                        djnz    keyboardCounter,         #resetDraobyek          '                        wrbyte  signExtensionMask,       keyboardLockStatesAdd   '                        mov     keyboardPacket,          #$FF                    ' Reset the keyboard.                        call    #keyboardTransmit                                '                        call    #keyboardReceive                                 ' Check if the keyboard passed its BAT.                        cmp     keyboardPacket,          #$AA wz                 'if_nz                   jmp     #resetKeyboard                                   '' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'                       Setup Keyboard' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////setupKeyboard           mov     keyboardPacket,          #$F2                    ' Read the keyboard's ID.                        call    #keyboardTransmit                                '                        call    #keyboardReceive                                 ' Check if a keyboard is attached.                        cmp     keyboardPacket,          #$AB wz                 'if_z                    call    #keyboardReceive                                 '                        cmp     keyboardPacket,          #$83 wz                 'if_nz                   jmp     #setupKeyboard                                   '                        mov     keyboardPacket,          #$F0                    ' Set scan code set.                        call    #keyboardTransmit                                '                        mov     keyboardPacket,          #3                      ' To scan code set 3.                        call    #keyboardTransmit                                '                        mov     keyboardPacket,          #$F0                    ' Set scan code set.                        call    #keyboardTransmit                                '                        mov     keyboardPacket,          #$00                    ' To scan code set 0.                        call    #keyboardTransmit                                '                        call    #keyboardReceive                                 ' Check scan code set.                        cmp     keyboardPacket,          #3 wz                   'if_nz                   jmp     #setupKeyboard                                   '                        mov     keyboardPacket,          #$FA                    ' Set all keys typematic/make/break.                        call    #keyboardTransmit                                '                        mov     keyboardPacket,          #$FC                    ' Disable typematic repeat for locks.                        call    #keyboardTransmit                                '                        mov     keyboardPacket,          #$76                    '                        call    #keyboardTransmit                                '                        mov     keyboardPacket,          #$5F                    '                        call    #keyboardTransmit                                '                        mov     keyboardPacket,          #$14                    '                        call    #keyboardTransmit                                '                        mov     keyboardPacket,          #$EE                    '                        call    #keyboardTransmit                                '                        neg     keyboardSetup,           #1                      ' Apply settings.                        wrbyte  keyboardSetup,           keyboardPresentAdd      '                        jmp     #updateKeyboardSettings                          '' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'                       Update Keyboard' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////updateKeyboard          mov     keyboardBuffer,          oneHalfSecondTimeout    ' Setup the timeout wait.updateKeyboardLoop      jmpret  keyboardPC,              synchronizePC           '                        test    keyboardClock,           ina wc                  ' Repeat until the clock goes low or timeout.if_c                    djnz    keyboardBuffer,          #updateKeyboardLoop     'if_c                    mov     keyboardPacket,          #$EE                    ' Ping the keyboard on timeout.if_c                    call    #keyboardTransmit                                '                        tjz     keyboardBuffer,          #updateKeyboard         ' Repeat on timeout.' //////////////////////Check Make Break///////////////////////////////////////////////////////////////////////////////////////                        call    #keyboardReceive                                 ' Check for make or break code.                        cmp     keyboardPacket,          #$F0 wz                 '                        muxnz   keyboardState,           #$8                     'if_z                    call    #keyboardReceive                                 '                        max     keyboardPacket,          #$8D                    '                        test    keyboardState,           #$8 wc                  '' //////////////////////Get Key////////////////////////////////////////////////////////////////////////////////////////////////                        mov     keyboardBuffer,          scanCodeLookupTableAdd  ' Preform the scan code table lookup.                        add     keyboardBuffer,          keyboardPacket          '                        rdbyte  keyboardBuffer,          keyboardBuffer          '                        tjz     keyboardBuffer,          #updateKeyboardSgnittes '' //////////////////////Set Key////////////////////////////////////////////////////////////////////////////////////////////////                        sub     keyboardBuffer,          #1                      ' Shift keys into position.                        mov     keyboardByteIndex,       keyboardBuffer          ' Build address and bit index.                        mov     keyboardBitIndex,        keyboardBuffer          '                        shr     keyboardByteIndex,       #3                      '                        and     keyboardBitIndex,        #$7                     '                        mov     keyboardBitMask,         #1                      ' Build keystate mask.                        shl     keyboardBitMask,         keyboardBitIndex        '                        add     keyboardByteIndex,       keyboardButtonStatesAdd '                        rdbyte  keyboardByteBuffer,      keyboardByteIndex       ' Edit keystate.                        muxc    keyboardByteBuffer,      keyboardBitMask         '                        wrbyte  keyboardByteBuffer,      keyboardByteIndex       '                        cmp     keyboardPacket,          #$12 wz                 ' Check shift key.if_nz                   cmp     keyboardPacket,          #$59 wz                 'if_z                    muxc    keyboardState,           #$10                    '                        cmp     keyboardPacket,          #$11 wz                 ' Check control key.if_nz                   cmp     keyboardPacket,          #$58 wz                 'if_z                    muxc    keyboardState,           #$20                    '                        cmp     keyboardPacket,          #$19 wz                 ' Check alternative key.if_nz                   cmp     keyboardPacket,          #$39 wz                 'if_z                    muxc    keyboardState,           #$40                    '                        cmp     keyboardPacket,          #$8B wz                 ' Check windows key.if_nz                   cmp     keyboardPacket,          #$8C wz                 'if_z                    muxc    keyboardState,           #$80                    '                        cmp     keyboardPacket,          #$14 wz                 ' Check caps lock state.if_z_and_c              xor     scrollNumCapsLock,       #$4                     '                        cmp     keyboardPacket,          #$76 wz                 ' Check number lock state.if_z_and_c              xor     scrollNumCapsLock,       #$2                     '                        cmp     keyboardPacket,          #$5F wz                 ' Check scroll lock state.if_z_and_c              xor     scrollNumCapsLock,       #$1                     '                        andn    keyboardState,           #$7                     ' Fill in keyboard state.                        or      keyboardState,           scrollNumCapsLock       '                        cmpsub  keyboardBuffer,          #26 wc, nr              ' Handle other ASCII characters.if_c                    cmp     keyboardBuffer,          #56 wc                  'if_c                    sub     keyboardBuffer,          #26                     'if_c                    add     keyboardBuffer,          ASCIICodeLookupTableAdd 'if_c                    test    keyboardState,           #$10 wz                 'if_c_and_nz             add     keyboardBuffer,          #30                     'if_c                    rdbyte  keyboardBuffer,          keyboardBuffer          'if_c                    jmp     #keyboardEnterCRLF                               '                        cmpsub  keyboardBuffer,          #56 wc, nr              ' Handle keypad characters.if_c                    cmp     keyboardBuffer,          #67 wc                  'if_c                    add     keyboardBuffer,          #(60 - 56)              'if_c                    add     keyboardBuffer,          ASCIICodeLookupTableAdd 'if_c                    test    keyboardState,           #$2 wz                  'if_c_and_nz             add     keyboardBuffer,          #11                     'if_c                    rdbyte  keyboardBuffer,          keyboardBuffer          'if_c_and_nz             jmp     #keyboardEnterCRLF                               '                        cmpsub  keyboardBuffer,          #67 wc, nr              ' Move all other keys to above 128.if_c                    add     keyboardBuffer,          #(128 - 67 + 1)         '                        cmp     keyboardBuffer,          #26 wc                  ' Handle A .. Z.if_c                    add     keyboardBuffer,          #"a"                    'if_c                    test    keyboardState,           #$14 wc                 'if_c                    sub     keyboardBuffer,          #32                     'keyboardEnterCRLF       mov     keyboardPacket,          keyboardState           ' Prepare key event.                        shl     keyboardPacket,          #8                      '                        or      keyboardPacket,          keyboardBuffer          '                        rdbyte  keyboardETail,           keyboardEventsTailAdd   ' Check if the buffer is full.                        mov     keyboardBuffer,          keyboardEHead           '                        sub     keyboardBuffer,          keyboardETail           '                        and     keyboardBuffer,          #$FF                    '                        cmp     keyboardBuffer,          #255 wc                 'if_c                    mov     keyboardBuffer,          keyboardEHead           ' Update the buffer if not full.if_c                    shl     keyboardBuffer,          #1                      'if_c                    add     keyboardBuffer,          keyboardEventsAdd       'if_c                    wrword  keyboardPacket,          keyboardBuffer          'if_c                    add     keyboardEHead,           #1                      'if_c                    and     keyboardEHead,           #$FF                    'if_c                    wrbyte  keyboardEHead,           keyboardEventsHeadAdd   '                        and     keyboardPacket,          #$FF                    ' Enter carriage return and line feed.                        cmp     keyboardPacket,          #13 wz                  'if_z                    mov     keyboardBuffer,          #10                     'if_z                    jmp     #keyboardEnterCRLF                               '' //////////////////////Change Settings////////////////////////////////////////////////////////////////////////////////////////updateKeyboardSettings  cmp     keyboardLEDs,            scrollNumCapsLock wz    ' Check if settings changed.if_z                    jmp     #updateKeyboardSgnittes                          '                        mov     keyboardLEDs,            scrollNumCapsLock       ' Update keyboard LEDs.                        mov     keyboardPacket,          #$ED                    '                        call    #keyboardTransmit                                '                        mov     keyboardPacket,          scrollNumCapsLock       '                        call    #keyboardTransmit                                'updateKeyboardSgnittes  wrbyte  scrollNumCapsLock,       keyboardLockStatesAdd   ' Update lock states.                        rdbyte  keyboardBuffer,          keyboardSettingsAddress ' Check if settings changed.                        cmp     keyboardBuffer,          keyboardSetup wz        'if_z                    jmp     #updateKeyboard                                  '                        mov     keyboardSetup,           keyboardBuffer          ' Update keyboard typematic settings.                        mov     keyboardPacket,          #$F3                    '                        call    #keyboardTransmit                                '                        mov     keyboardPacket,          keyboardSetup           '                        call    #keyboardTransmit                                '' //////////////////////Loop///////////////////////////////////////////////////////////////////////////////////////////////////                        jmp     #updateKeyboard                                  ' Loop.' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'                       Keyboard Receive Packet' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////keyboardReceive         mov     keyboardCounter,         #11                     ' Setup to recieve the packet.' //////////////////////Receive////////////////////////////////////////////////////////////////////////////////////////////////keyboardReceiveLoop     call    #keyboardClockLow                                ' Wait until the clock is low.                        test    keyboardData,            ina wc                  ' Input bits.                        rcr     keyboardPacket,          #1                      '                        call    #keyboardClockHigh                               ' Wait until the clock is high.                        djnz    keyboardCounter,         #keyboardReceiveLoop    ' Repeat 11 times.                        shr     keyboardPacket,          #22                     ' Remove start bit.' //////////////////////Remove Parity//////////////////////////////////////////////////////////////////////////////////////////                        test    keyboardPacket,          #$1FF wc                ' Remove parity bit and stop bit.if_nc                   jmp     #resetKeyboard                                   '                        and     keyboardPacket,          #$FF                    '' //////////////////////Return/////////////////////////////////////////////////////////////////////////////////////////////////keyboardReceive_ret     ret                                                      ' Return.' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'                       Transmit Packet' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////keyboardTransmit        mov     keyboardCounter,         #12                     ' Setup to request to transmit.' //////////////////////Request To Transmit////////////////////////////////////////////////////////////////////////////////////                        or      dira,                    keyboardClock           ' Request to transmit.keyboardRequest         jmpret  keyboardPC,              synchronizePC           ' Wait for request to transmit.                        djnz    keyboardCounter,         #keyboardRequest        '                        or      dira,                    keyboardData            ' Transmit start bit.                        andn    dira,                    keyboardClock           '' //////////////////////Add Parity/////////////////////////////////////////////////////////////////////////////////////////////                        movd    keyboardPacket,          #$3                     ' Add parity to the data packet.                        test    keyboardPacket,          #$FF wc                 '                        muxnc   keyboardPacket,          #$100                   '                        mov     keyboardCounter,         #11                     ' Setup to transmit the packet.' //////////////////////Transmit///////////////////////////////////////////////////////////////////////////////////////////////keyboardTransmitLoop    call    #keyboardClockLow                                ' Wait until the clock is low.                        shr     keyboardPacket,          #1 wc                   ' Output Bits.                        muxnc   dira,                    keyboardData            '                        call    #keyboardClockHigh                               ' Wait until the clock is high.                        djnz    keyboardCounter,         #keyboardTransmitLoop   ' Repeat 11 times.' //////////////////////Aknowledge Byte////////////////////////////////////////////////////////////////////////////////////////                        call    #keyboardReceive                                 ' Receive aknowledgement byte.                        cmp     keyboardPacket,          #$FA wz                 'if_nz                   cmp     keyboardPacket,          #$EE wz                 'if_nz                   jmp     #resetKeyboard                                   '' //////////////////////Return/////////////////////////////////////////////////////////////////////////////////////////////////keyboardTransmit_ret    ret                                                      ' Return.' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'                       Keyboard Clock Low/High' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////keyboardClockLow        movi    keyboardClockLHTest,     #%011000_010            ' Test if clock low and testn if clock high.                        jmp     #keyboardClockLHJump                             'keyboardClockHigh       movi    keyboardClockLHTest,     #%011001_010            'keyboardClockLHJump     mov     keyboardTimeCounter,     oneHalfSecondTimeout    ' Setup the timeout wait.' //////////////////////Sample/////////////////////////////////////////////////////////////////////////////////////////////////keyboardClockLHLoop     jmpret  keyboardPC,              synchronizePC           ' Sample clock line.keyboardClockLHTest     test    keyboardClock,           ina wc                  'if_c                    djnz    keyboardTimeCounter,     #keyboardClockLHLoop    ' Repeat until the clock changes or timeout.if_c                    jmp     #resetKeyboard                                   '' //////////////////////Wait///////////////////////////////////////////////////////////////////////////////////////////////////                        jmpret  keyboardPC,              synchronizePC           ' Wait until near the middle of the bit.keyboardClockLow_ret                                                             ' Return.keyboardClockHigh_ret   ret                                                      '' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'                       Reset Mouse' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////resetMouse              andn    dira,                    mouseData               ' Reset mouse data line state.                        wrbyte  signExtensionMask,       mousePresentAdd         '                        wrbyte  signExtensionMask,       mouseButtonStatesAdd    ' Reset mouse buttons states.                        mov     mousePacket,             #$FF                    ' Reset the mouse.                        call    #mouseTransmitPacket                             '                        call    #mouseReceivePacket                              ' Check if the mouse passed its BAT.                        cmp     mousePacket,             #$AA wz                 'if_nz                   jmp     #resetMouse                                      '' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'                       Setup Mouse' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////setupMouse              mov     mousePacket,             #$F2                    ' Read the mouse's ID.                        call    #mouseTransmitPacket                             '                        call    #mouseReceivePacket                              ' Check if a mouse is attached.                        tjnz    mousePacket,             #setupMouse             '                        mov     mousePacket,             #$F3                    ' Set sample rate.                        call    #mouseTransmitPacket                             '                        mov     mousePacket,             #200                    ' To 200 samples per second.                        call    #mouseTransmitPacket                             '                        mov     mousePacket,             #$F3                    ' Set sample rate.                        call    #mouseTransmitPacket                             '                        mov     mousePacket,             #100                    ' To 100 samples per second.                        call    #mouseTransmitPacket                             '                        mov     mousePacket,             #$F3                    ' Set sample rate.                        call    #mouseTransmitPacket                             '                        mov     mousePacket,             #80                     ' To 80 samples per second.                        call    #mouseTransmitPacket                             '                        mov     mousePacket,             #$F2                    ' Get device ID.                        call    #mouseTransmitPacket                             '                        call    #mouseReceivePacket                              ' Save mouse type.                        mov     mouseType,               mousePacket             '                        mov     mousePacket,             #$F3                    ' Set sample rate.                        call    #mouseTransmitPacket                             '                        mov     mousePacket,             #200                    ' To 200 samples per second.                        call    #mouseTransmitPacket                             '                        mov     mousePacket,             #$F4                    ' Enable data reporting.                        call    #mouseTransmitPacket                             '                        neg     mouseSetup,              #1                      ' Apply settings.                        wrbyte  mouseSetup,              mousePresentAdd         '                        jmp     #updateMouseSettings                             '' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'                       Update Mouse' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////updateMouse             mov     mouseTimeCounter,        oneHalfSecondTimeout    ' Setup the timeout wait.updateMouseLoop         jmpret  mousePC,                 synchronizePC           '                        test    mouseClock,              ina wc                  ' Repeat until the clock goes low or timeout.if_c                    djnz    mouseTimeCounter,        #updateMouseLoop        'if_c                    mov     mousePacket,             #$EB                    ' Ping the mouse on timeout.if_c                    call    #mouseTransmitPacket                             '                        call    #mouseReceivePacket                              ' Receive and copy mouse state data packet.                        mov     mouseState,              mousePacket             '' //////////////////////Decode and Update X Axis Movement//////////////////////////////////////////////////////////////////////                        call    #mouseReceivePacket                              ' Receive x axis movement data packet.                        test    mouseState,              #$40 wz                 ' Decode and add x axis movement.                        test    mouseState,              #$10 wc                 '                        negc    mouseBuffer,             #255                    '                        muxc    mousePacket,             signExtensionMask       'if_nz                   add     mousePacket,             mouseBuffer             '                        cmp     mousePacket,             #0 wz                   ' Alert movement event.                        muxnz   mouseXMovement,          #$40                    '                        rdword  mouseXPositionCounter,   mouseXAxisPositionAdd   ' Update part of x axis.                        add     mouseXPositionCounter,   mousePacket             '                        maxs    mouseXPositionCounter,   cutOffX                 '                        mins    mouseXPositionCounter,   #0                      '                        wrword  mouseXPositionCounter,   mouseXAxisPositionAdd   '' //////////////////////Decode and Update Y Axis Movement//////////////////////////////////////////////////////////////////////                        call    #mouseReceivePacket                              ' Receive y axis movement data packet.                        test    mouseState,              #$80 wz                 ' Decode and add y axis movement.                        test    mouseState,              #$20 wc                 '                        negc    mouseBuffer,             #255                    '                        muxc    mousePacket,             signExtensionMask       'if_nz                   add     mousePacket,             mouseBuffer             '                        cmp     mousePacket,             #0 wz                   ' Alert movement event.                        muxnz   mouseYMovement,          #$80                    '                        rdword  mouseYPositionCounter,   mouseYAxisPositionAdd   ' Update part of y axis.                        sub     mouseYPositionCounter,   mousePacket             '                        maxs    mouseYPositionCounter,   cutOffY                 '                        mins    mouseYPositionCounter,   #0                      '                        wrword  mouseYPositionCounter,   mouseYAxisPositionAdd   '' //////////////////////Check Mouse Type///////////////////////////////////////////////////////////////////////////////////////                        cmp     mouseType,               #3 wz                   ' Check the mouse type.if_nz                   jmp     #mouseSkip                                       '' //////////////////////Decode and Update Z Axis Movement//////////////////////////////////////////////////////////////////////                        call    #mouseReceivePacket                              ' Receive z axis movement data packet.                        shl     mousePacket,             #28                     ' Decode and add z axis movement.                        sar     mousePacket,             #28                     '                        rdlong  mouseBuffer,             par                     ' Update part of z axis.                        sub     mouseBuffer,             mousePacket             '                        wrlong  mouseBuffer,             par                     '' //////////////////////Decode and Update Mouse Events/////////////////////////////////////////////////////////////////////////mouseSkip               mov     mousePacket,             mouseYPositionCounter   ' Pack mouse x and y positions.                        shl     mousePacket,             #12                     '                        or      mousePacket,             mouseXPositionCounter   '                        shl     mousePacket,             #8                      '                        rdbyte  mouseBuffer,             mouseButtonStatesAdd    ' Update mouse states.                        wrbyte  mouseState,              mouseButtonStatesAdd    '                        test    mouseBuffer,             #$1 wc                  ' Add in left button events.                        test    mouseState,              #$1 wz                  'if_nc_and_nz            or      mousePacket,             #$1                     'if_c_and_z              or      mousePacket,             #$8                     '                        test    mouseBuffer,             #$2 wc                  ' Add in right button events.                        test    mouseState,              #$2 wz                  'if_nc_and_nz            or      mousePacket,             #$2                     'if_c_and_z              or      mousePacket,             #$10                    '                        test    mouseBuffer,             #$4 wc                  ' Add in middle button events.                        test    mouseState,              #$4 wz                  'if_nc_and_nz            or      mousePacket,             #$4                     'if_c_and_z              or      mousePacket,             #$20                    'mouseXMovement          or      mousePacket,             #$40                    ' Add in movement events.mouseYMovement          or      mousePacket,             #$80                    '                        test    mousePacket,             #$FF wz                 ' Check mouse packet event.if_nz                   rdbyte  mouseETail,              mouseEventsTailAdd      ' Check if the buffer is full.if_nz                   mov     mouseBuffer,             mouseEHead              'if_nz                   sub     mouseBuffer,             mouseETail              'if_nz                   and     mouseBuffer,             #$FF                    'if_nz                   cmp     mouseBuffer,             #255 wc                 'if_c_and_nz             mov     mouseBuffer,             mouseEHead              ' Update the buffer if not full.if_c_and_nz             shl     mouseBuffer,             #2                      'if_c_and_nz             add     mouseBuffer,             mouseEventsAdd          'if_c_and_nz             wrlong  mousePacket,             mouseBuffer             'if_c_and_nz             add     mouseEHead,              #1                      'if_c_and_nz             and     mouseEHead,              #$FF                    'if_c_and_nz             wrbyte  mouseEHead,              mouseEventsHeadAdd      '' //////////////////////Change Settings////////////////////////////////////////////////////////////////////////////////////////updateMouseSettings     rdbyte  mouseBuffer,             mouseSettingsAddress    ' Check if settings changed.                        cmp     mouseBuffer,             mouseSetup wz           'if_z                    jmp     #updateMouse                                     '                        mov     mouseSetup,              mouseBuffer             ' Setup mouse scaling and resolution.                        shr     mouseBuffer,             #1 wc                   '                        muxc    sendMouseScaling,        #1                      '                        movs    sendMouseResoltuion,     mouseBuffer             '                        mov     mousePacket,             #$E8                    ' Update mouse settings.                        call    #mouseTransmitPacket                             'sendMouseResoltuion     mov     mousePacket,             #0                      '                        call    #mouseTransmitPacket                             'sendMouseScaling        mov     mousePacket,             #$E6                    '                        call    #mouseTransmitPacket                             '' //////////////////////Loop///////////////////////////////////////////////////////////////////////////////////////////////////                        jmp     #updateMouse                                     ' Loop.' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'                       Mouse Receive Packet' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////mouseReceivePacket      mov     mouseCounter,            #11                     ' Setup to receive the packet.' //////////////////////Receive////////////////////////////////////////////////////////////////////////////////////////////////mouseReceiveLoop        call    #mouseClockLow                                   ' Wait until the clock is low.                        test    mouseData,               ina wc                  ' Input bits.                        rcr     mousePacket,             #1                      '                        call    #mouseClockHigh                                  ' Wait until the clock is high.                        djnz    mouseCounter,            #mouseReceiveLoop       ' Repeat 11 times.                        shr     mousePacket,             #22                     ' Remove start bit.' //////////////////////Remove Parity//////////////////////////////////////////////////////////////////////////////////////////                        test    mousePacket,             #$1FF wc                ' Remove parity bit and stop bit.if_nc                   jmp     #resetMouse                                      '                        and     mousePacket,             #$FF                    '' //////////////////////Return/////////////////////////////////////////////////////////////////////////////////////////////////mouseReceivePacket_ret  ret                                                      ' Return.' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'                       Mouse Transmit Packet' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////mouseTransmitPacket     mov     mouseCounter,            #12                     ' Setup to request to transmit.' //////////////////////Request To Transmit////////////////////////////////////////////////////////////////////////////////////                        or      dira,                    mouseClock              ' Request to transmit.mouseRequest            jmpret  mousePC,                 synchronizePC           ' Wait for request to transmit.                        djnz    mouseCounter,            #mouseRequest           '                        or      dira,                    mouseData               ' Transmit start bit.                        andn    dira,                    mouseClock              '' //////////////////////Add Parity/////////////////////////////////////////////////////////////////////////////////////////////                        movd    mousePacket,             #$3                     ' Add parity to the data packet.                        test    mousePacket,             #$FF wc                 '                        muxnc   mousePacket,             #$100                   '                        mov     mouseCounter,            #11                     ' Setup to transmit the packet.' //////////////////////Transmit///////////////////////////////////////////////////////////////////////////////////////////////mouseTransmitLoop       call    #mouseClockLow                                   ' Wait until the clock is low.                        shr     mousePacket,             #1 wc                   ' Output bits.                        muxnc   dira,                    mouseData               '                        call    #mouseClockHigh                                  ' Wait until the clock is high.                        djnz    mouseCounter,            #mouseTransmitLoop      ' Repeat 11 times.' //////////////////////Aknowledge Byte////////////////////////////////////////////////////////////////////////////////////////                        call    #mouseReceivePacket                              ' Receive aknowledgement byte.                        cmp     mousePacket,             #$FA wz                 'if_nz                   jmp     #resetMouse                                      '' //////////////////////Return/////////////////////////////////////////////////////////////////////////////////////////////////mouseTransmitPacket_ret ret                                                      ' Return.' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'                       Mouse Clock Low/High' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////mouseClockLow           movi    mouseClockLHTest,        #%011000_010            ' Test if clock low and testn if clock high.                        jmp     #mouseClockLHJump                                'mouseClockHigh          movi    mouseClockLHTest,        #%011001_010            'mouseClockLHJump        mov     mouseTimeCounter,        oneHalfSecondTimeout    ' Setup the timeout wait.' //////////////////////Sample/////////////////////////////////////////////////////////////////////////////////////////////////mouseClockLHLoop        jmpret  mousePC,                 synchronizePC           ' Sample clock line.mouseClockLHTest        test    mouseClock,              ina wc                  'if_c                    djnz    mouseTimeCounter,        #mouseClockLHLoop       ' Repeat until the clock changes or timeout.if_c                    jmp     #resetMouse                                      '' //////////////////////Wait///////////////////////////////////////////////////////////////////////////////////////////////////                        jmpret  mousePC,                 synchronizePC           ' Wait until near the middle of the bit.mouseClockLow_ret                                                                ' Return.mouseClockHigh_ret      ret                                                      '' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'                       Data' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////operationFrequency      long    0scrollNumCapsLock       long    0cutOffX                 long    0cutOffY                 long    0' //////////////////////Constants//////////////////////////////////////////////////////////////////////////////////////////////signExtensionMask       long    $FF_FF_FF_00                                     ' Byte sign extension mask.oneHalfSecondTimeout    long    40_000                                           ' One half second timeout at 80KHz.' //////////////////////Pin Masks//////////////////////////////////////////////////////////////////////////////////////////////keyboardClock           long    0keyboardData            long    0mouseClock              long    0mouseData               long    0' //////////////////////Addresses//////////////////////////////////////////////////////////////////////////////////////////////ASCIICodeLookupTableAdd long    0scanCodeLookupTableAdd  long    0mouseXAxisPositionAdd   long    0mouseYAxisPositionAdd   long    0keyboardPresentAdd      long    0mousePresentAdd         long    0keyboardSettingsAddress long    0mouseSettingsAddress    long    0keyboardEventsHeadAdd   long    0keyboardEventsTailAdd   long    0mouseEventsHeadAdd      long    0mouseEventsTailAdd      long    0keyboardEventsAdd       long    0mouseEventsAdd          long    0keyboardButtonStatesAdd long    0keyboardLockStatesAdd   long    0mouseButtonStatesAdd    long    0' //////////////////////Run Time Variables/////////////////////////////////////////////////////////////////////////////////////synchronizeTime         res     1synchronizePC           res     1' //////////////////////Keyboard Variables/////////////////////////////////////////////////////////////////////////////////////keyboardState           res     1keyboardPacket          res     1keyboardBuffer          res     1keyboardCounter         res     1keyboardTimeCounter     res     1keyboardPC              res     1keyboardEHead           res     1keyboardETail           res     1keyboardLEDs            res     1keyboardSetup           res     1keyboardBitIndex        res     1keyboardByteIndex       res     1keyboardBitMask         res     1keyboardByteBuffer      res     1' //////////////////////Mouse Variables////////////////////////////////////////////////////////////////////////////////////////mouseState              res     1mousePacket             res     1mouseBuffer             res     1mouseCounter            res     1mouseTimeCounter        res     1mousePC                 res     1mouseETail              res     1mouseEHead              res     1mouseType               res     1mouseSetup              res     1mouseXPositionCounter   res     1mouseYPositionCounter   res     1' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////                        fit     496DAT' //////////////////////Global Variable Array//////////////////////////////////////////////////////////////////////////////////mouseXAxisPosition      word    0                                                ' Position information.mouseYAxisPosition      word    0                                                'mouseZAxisPosition      long    0                                                'keyboardPresent         byte    0                                                ' State information.mousePresent            byte    0                                                'keyboardSettings        byte    0                                                ' Keyboard and mouse state variables.mouseSettings           byte    0                                                'keyboardEventsHead      byte    0                                                ' Keyboard event queue pointers.keyboardEventsTail      byte    0                                                'mouseEventsHead         byte    0                                                ' Mouse event queue pointers.mouseEventsTail         byte    0                                                'keyboardEvents          word    0[256]                                           ' Event queues.mouseEvents             long    0[256]                                           'keyboardButtonStates    byte    0[13]                                            ' Button information.keyboardLockStates      byte    0                                                'mouseButtonStates       byte    0                                                'keyboardLockNumber      byte    0                                                ' Resource IDs.mouseLockNumber         byte    0                                                'cogNumber               byte    0                                                '' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////DAT' //////////////////////ASCII Code Lookup Table////////////////////////////////////////////////////////////////////////////////ASCIICodeLookupTable    byte    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", $27, ",", "-", ".", "/"                        byte    ";", "=", "[", "\", "]", "`", $08, $09, $20, $0D, $0D, "*", "+", "-", "/"                        byte    ")", "!", "@", "#", "$", "%", "^", "&", "*", "(", $22, "<", "_", ">", "?"                        byte    ":", "+", "{", "|", "}", "~", $08, $09, $20, $0D, $0D, "*", "+", "-", "/"                        byte    087, 086, 085, 081, 083, 078, 049, 079, 084, 080, 082                        byte    ".", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"' //////////////////////Scan Code Look Up Table////////////////////////////////////////////////////////////////////////////////scanCodeLookupTable     byte    0                                                ' $00                        byte    0                                                ' $01                        byte    0                                                ' $02                        byte    0                                                ' $03                        byte    0                                                ' $04                        byte    0                                                ' $05                        byte    0                                                ' $06                        byte    093                                              ' $07 F1                        byte    089                                              ' $08 Escape                        byte    0                                                ' $09                        byte    0                                                ' $0A                        byte    0                                                ' $0B                        byte    0                                                ' $0C                        byte    049                                              ' $0D Tab                        byte    047                                              ' $0E `                        byte    094                                              ' $0F F2                        byte    0                                                ' $10                        byte    072                                              ' $11 Left Control                        byte    071                                              ' $12 Left Shift                        byte    0                                                ' $13                        byte    070                                              ' $14 Caps Lock                        byte    017                                              ' $15 Q                        byte    028                                              ' $16 1                        byte    095                                              ' $17 F3                        byte    0                                                ' $18                        byte    073                                              ' $19 Left Alternative                        byte    026                                              ' $1A Z                        byte    019                                              ' $1B S                        byte    001                                              ' $1C A                        byte    023                                              ' $1D W                        byte    029                                              ' $1E 2                        byte    096                                              ' $1F F4                        byte    0                                                ' $20                        byte    003                                              ' $21 C                        byte    024                                              ' $22 X                        byte    004                                              ' $23 D                        byte    005                                              ' $24 E                        byte    031                                              ' $25 4                        byte    030                                              ' $26 3                        byte    097                                              ' $27 F5                        byte    0                                                ' $28                        byte    050                                              ' $29 Space                        byte    022                                              ' $2A V                        byte    006                                              ' $2B F                        byte    020                                              ' $2C T                        byte    018                                              ' $2D R                        byte    032                                              ' $2E 5                        byte    098                                              ' $2F F6                        byte    0                                                ' $30                        byte    014                                              ' $31 N                        byte    002                                              ' $32 B                        byte    008                                              ' $33 H                        byte    007                                              ' $34 G                        byte    025                                              ' $35 Y                        byte    033                                              ' $36 6                        byte    099                                              ' $37 F7                        byte    0                                                ' $38                        byte    077                                              ' $39 Right Alternative                        byte    013                                              ' $3A M                        byte    010                                              ' $3B J                        byte    021                                              ' $3C U                        byte    034                                              ' $3D 7                        byte    035                                              ' $3E 8                        byte    100                                              ' $3F F8                        byte    0                                                ' $40                        byte    038                                              ' $41 ,                        byte    011                                              ' $42 K                        byte    009                                              ' $43 I                        byte    015                                              ' $44 O                        byte    027                                              ' $45 0                        byte    036                                              ' $46 9                        byte    101                                              ' $47 F9                        byte    0                                                ' $48                        byte    040                                              ' $49 .                        byte    041                                              ' $4A /                        byte    012                                              ' $4B L                        byte    042                                              ' $4C ;                        byte    016                                              ' $4D P                        byte    039                                              ' $4E -                        byte    102                                              ' $4F F10                        byte    0                                                ' $50                        byte    0                                                ' $51                        byte    037                                              ' $52 '                        byte    0                                                ' $53                        byte    044                                              ' $54 [                        byte    043                                              ' $55 =                        byte    103                                              ' $56 F11                        byte    091                                              ' $57 Print Screen System Request                        byte    076                                              ' $58 Right Control                        byte    075                                              ' $59 Right Shift                        byte    051                                              ' $5A Enter                        byte    046                                              ' $5B ]                        byte    045                                              ' $5C \                        byte    0                                                ' $5D                        byte    104                                              ' $5E F12                        byte    068                                              ' $5F Scroll Lock                        byte    082                                              ' $60 Down Arrow                        byte    079                                              ' $61 Left Arrow                        byte    092                                              ' $62 Pause Break                        byte    081                                              ' $63 Up Arrow                        byte    088                                              ' $64 Delete                        byte    086                                              ' $65 End                        byte    048                                              ' $66 Backspace                        byte    087                                              ' $67 Insert                        byte    0                                                ' $68                        byte    059                                              ' $69 Keypad 1                        byte    080                                              ' $6A Right Arrow                        byte    062                                              ' $6B Keypad 4                        byte    065                                              ' $6C Keypad 7                        byte    084                                              ' $6D Page Down                        byte    085                                              ' $6E Home                        byte    083                                              ' $6F Page Up                        byte    058                                              ' $70 Keypad 0                        byte    057                                              ' $71 Keypad .                        byte    060                                              ' $72 Keypad 2                        byte    063                                              ' $73 Keypad 5                        byte    064                                              ' $74 Keypad 6                        byte    066                                              ' $75 Keypad 8                        byte    069                                              ' $76 Number Lock                        byte    056                                              ' $77 Keypad /                        byte    0                                                ' $78                        byte    052                                              ' $79 Keypad Enter                        byte    061                                              ' $7A Keypad 3                        byte    0                                                ' $7B                        byte    054                                              ' $7C Keypad +                        byte    067                                              ' $7D Keypad 9                        byte    053                                              ' $7E Keypad *                        byte    0                                                ' $7F                        byte    0                                                ' $80                        byte    0                                                ' $81                        byte    0                                                ' $82                        byte    0                                                ' $83                        byte    055                                              ' $84 Keypad -                        byte    0                                                ' $85                        byte    0                                                ' $86                        byte    0                                                ' $87                        byte    0                                                ' $88                        byte    0                                                ' $89                        byte    0                                                ' $8A                        byte    074                                              ' $8B Left Windows                        byte    078                                              ' $8C Right Windows                        byte    090                                              ' $8D Applications' //////////////////////Scan Code Linear Table//////////////////////////////////////////////////////////////////////////////////                     '  byte    $1C                                              ' 0   A                     '  byte    $32                                              ' 1   B                     '  byte    $21                                              ' 2   C                     '  byte    $23                                              ' 3   D                     '  byte    $24                                              ' 4   E                     '  byte    $2B                                              ' 5   F                     '  byte    $34                                              ' 6   G                     '  byte    $33                                              ' 7   H                     '  byte    $43                                              ' 8   I                     '  byte    $3B                                              ' 9   J                     '  byte    $42                                              ' 10  K                     '  byte    $4B                                              ' 11  L                     '  byte    $3A                                              ' 12  M                     '  byte    $31                                              ' 13  N                     '  byte    $44                                              ' 14  O                     '  byte    $4D                                              ' 15  P                     '  byte    $15                                              ' 16  Q                     '  byte    $2D                                              ' 17  R                     '  byte    $1B                                              ' 18  S                     '  byte    $2C                                              ' 19  T                     '  byte    $3C                                              ' 20  U                     '  byte    $2A                                              ' 21  V                     '  byte    $1D                                              ' 22  W                     '  byte    $22                                              ' 23  X                     '  byte    $35                                              ' 24  Y                     '  byte    $1A                                              ' 25  Z                     '  byte    $45                                              ' 26  0                     '  byte    $16                                              ' 27  1                     '  byte    $1E                                              ' 28  2                     '  byte    $26                                              ' 29  3                     '  byte    $25                                              ' 30  4                     '  byte    $2E                                              ' 31  5                     '  byte    $36                                              ' 32  6                     '  byte    $3D                                              ' 33  7                     '  byte    $3E                                              ' 34  8                     '  byte    $46                                              ' 35  9                     '  byte    $52                                              ' 36  '                     '  byte    $41                                              ' 37  ,                     '  byte    $4E                                              ' 38  -                     '  byte    $49                                              ' 39  .                     '  byte    $4A                                              ' 40  /                     '  byte    $4C                                              ' 41  ;                     '  byte    $55                                              ' 42  =                     '  byte    $54                                              ' 43  [                     '  byte    $5C                                              ' 44  \                     '  byte    $5B                                              ' 45  ]                     '  byte    $0E                                              ' 46  `                     '  byte    $66                                              ' 47  Backspace                     '  byte    $0D                                              ' 48  Tab                     '  byte    $29                                              ' 49  Space                     '  byte    $5A                                              ' 50  Enter                     '  byte    $79                                              ' 51  Key Pad Enter                     '  byte    $7E                                              ' 52  Key Pad *                     '  byte    $7C                                              ' 53  Key Pad +                     '  byte    $84                                              ' 54  Key Pad -                     '  byte    $77                                              ' 55  Key Pad /                     '  byte    $71                                              ' 56  Key Pad .                     '  byte    $70                                              ' 57  Key Pad 0                     '  byte    $69                                              ' 58  Key Pad 1                     '  byte    $72                                              ' 59  Key Pad 2                     '  byte    $7A                                              ' 60  Key Pad 3                     '  byte    $6B                                              ' 61  Key Pad 4                     '  byte    $73                                              ' 62  Key Pad 5                     '  byte    $74                                              ' 63  Key Pad 6                     '  byte    $6C                                              ' 64  Key Pad 7                     '  byte    $75                                              ' 65  Key Pad 8                     '  byte    $7D                                              ' 66  Key Pad 9                     '  byte    $5F                                              ' 67  Scroll Lock                     '  byte    $76                                              ' 68  Number Lock                     '  byte    $14                                              ' 69  Caps Lock                     '  byte    $12                                              ' 70  Left Shift                     '  byte    $11                                              ' 71  Left Control                     '  byte    $19                                              ' 72  Left Alternative                     '  byte    $8B                                              ' 73  Left Windows                     '  byte    $59                                              ' 74  Right Shift                     '  byte    $58                                              ' 75  Right Control                     '  byte    $39                                              ' 76  Right Alternative                     '  byte    $8C                                              ' 77  Right Windows                     '  byte    $61                                              ' 78  Left Arrow                     '  byte    $6A                                              ' 79  Right Arrow                     '  byte    $63                                              ' 80  Up Arrow                     '  byte    $60                                              ' 81  Down Arrow                     '  byte    $6F                                              ' 82  Page Up                     '  byte    $6D                                              ' 83  Page Down                     '  byte    $6E                                              ' 84  Home                     '  byte    $65                                              ' 85  End                     '  byte    $67                                              ' 86  Insert                     '  byte    $64                                              ' 87  Delete                     '  byte    $08                                              ' 88  Escape                     '  byte    $8D                                              ' 89  Applications                     '  byte    $57                                              ' 90  Print Screen System Request                     '  byte    $62                                              ' 91  Pause Break                     '  byte    $07                                              ' 92  F1                     '  byte    $0F                                              ' 93  F2                     '  byte    $17                                              ' 94  F3                     '  byte    $1F                                              ' 95  F4                     '  byte    $27                                              ' 96  F5                     '  byte    $2F                                              ' 97  F6                     '  byte    $37                                              ' 98  F7                     '  byte    $3F                                              ' 99  F8                     '  byte    $47                                              ' 100 F9                     '  byte    $4F                                              ' 101 F10                     '  byte    $56                                              ' 102 F11                     '  byte    $5E                                              ' 103 F12' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////{{/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////                                                  TERMS OF USE: MIT License///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation// files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy,// modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the// Software is furnished to do so, subject to the following conditions://// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the// Software.//// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////}}